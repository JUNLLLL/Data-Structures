## 时间、空间复杂度

把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？

这种事后统计法是正确评估执行效率的方法，但是有非常大的局限性。

- 1、测试结果非常依赖测试环境（电脑配置）
- 2、测试结果受数据规模的影响很大

所以**我们需要一试个不用具体的测数据来测试，就可以粗略地估计算法的执行效率的方法。**

## 大 O 复杂度表示法

```java
int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。
第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n*unit_time 的执行时间，
所以这段代码总的执行时间就是 (2n+2)*unit_time。
```java
int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
```
第 2、3、4 行代码，每行都需要 1 个 unit_time 的执行时间，第 5、6 行代码循环执行了 n 遍，需要 2n * unit_time 的执行时间，
第 7、8 行代码循环执行了 n2遍，所以需要 2n2 * unit_time 的执行时间。所以，整段代码总的执行时间 T(n) = (2n2+2n+3)*unit_time。

尽管我们不知道 unit_time 的具体值，但是通过这两段代码执行时间的推导过程，得到一个非常重要的规律，
**所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。**把这个总结成一个公式大 O 复杂度表示法

                                   ` T(n) = O(f(n))`