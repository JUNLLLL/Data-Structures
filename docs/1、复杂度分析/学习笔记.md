# 时间、空间复杂度学习笔记

## 1、事后统计法
把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小，
并且能够正确评估执行效率的方法，但是有非常大的局限性。

- 1、测试结果非常依赖测试环境（电脑配置）；
- 2、测试结果受数据规模的影响很大。

## 2、大 O 复杂度表示法
```java
int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```
假设每行代码执行的时间都一样，为 unit_time。第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，
所以需要 2n*unit_time 的执行时间，总的执行时间就是 (2n+2)*unit_time。
```java
int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
```
第 2、3、4 行代码，每行都需要 1 个 unit_time 的执行时间，第 5、6 行代码循环执行了 n 遍，需要 2n * unit_time 的执行时间，
第 7、8 行代码循环执行了 n2遍，所以需要 2n2 * unit_time 的执行时间。整段代码总的执行时间 T(n) = (2n2+2n+3)*unit_time。

**所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比，转换成大 O 复杂度表示法：**
  **<p align="center">T(n) = O(f(n))</p>**
其中`T(n)`它表示代码执行的时间；n 表示数据规模的大小；`f(n)`表示每行代码执行的次数总和。 
替换 unit_time，第一个例子中的 T(n) = O(2n+2)，第二个例子中的 T(n) = O(2n2+2n+3)；
当 n 很大时，就可以记为：T(n) = O(n)； T(n) = O(n2);

**Note:大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，也叫作渐进时间复杂度，简称时间复杂度;** 

 ## 3、时间复杂度分析
 
 - 1、只关注循环执行次数最多的一段代码；
 - 2、加法法则：总复杂度等于量级最大的那段代码的复杂度；
 - 3、乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积（一个方法的循环代码执行另一个带有循环的方法）。
 
##  4、几种常见时间复杂度实例分析
 
 ![复杂量度级](复杂度量级.jpg)
 主要分为多项式量级和非多项式量级。非多项式量级只有两个：O(2`n) 和 O(n!)，其复杂度计算机往往不能承受。
 ### 1、O(1)
 O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。
 （一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)）
###  2、O(logn)、O(nlogn)
```java
i=1;
 while (i <= n)  {
   i = i * 2;
 }
```
时间复杂度计算得到： 2x=n ---> x=log2n ---> O(log2n)
不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn),对数之间是可以互相转换的,同时常量可以忽略不记。
O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)

### 3、O(m+n)、O(m*n)

无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个，可以使用 O(m+n)

### 4、内容小结
常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2)

![复杂度走势图](复杂度走势图.jpg)

## 5、空间复杂度分析

空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。

```java
void print(int n) {
  int i = 0;
  int[] a = new int[n];
}
```
跟时间复杂度分析一样，第2行申请了一个空间存储变量i,常量阶的不影响数据规模n的值可以忽略,所以代码的空间复杂度就是 O(n)。
常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。

## 6、复杂度分析进阶

### 1、最好、最坏情况时间复杂度
- 最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度;
- 最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。
```java
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```
上面的例子是在一个无序的数组（array）中，查找变量 x 出现的位置:

最好情况时间：如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)；

最坏情况时间：如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。

### 2、平均情况时间复杂度

### 3、均摊时间复杂度

大部分情况下，我们并不需要区分最好、最坏、平均三种复杂度。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。
