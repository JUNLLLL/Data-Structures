# 排序学习笔记


![](排序对比图.png)

## 如何分析一个“排序算法”？
### 排序算法的执行效率
- 最好情况、最坏情况、平均情况时间复杂度
- 时间复杂度的系数、常数 、低阶
- 比较次数和交换（或移动）次数
### 排序算法的内存消耗
### 排序算法的稳定性
如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。
## 复杂度(n2)的排序
### 冒泡排序（Bubble Sort）

![](冒泡排序图.png)

```java
// 冒泡排序，a 表示数组，n 表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```
### 插入排序（Insertion Sort）

![](插入排序图.png)

```java
// 插入排序，a 表示数组，n 表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;
 
  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```
### 选择排序（Selection Sort）

![](选择排序图.png)

```java
public void  SelectSort(int[] array)
{
   int temp;
    for (int i = 0; i < array.Length; i++){
        int min = i;

        for (int j = i+1; j < array.Length; j++){
            if (array[j] < array[min])
                    min = j;
        }
        //不用一直交换，只需要最后交互一次
        if (min != i){
         
            temp = array[i];
            array[i] = array[min];
            array[min] = temp;
        }
    }
}
```
### 三种排序对比图
![](n2排序比较.png)

### 为什么插入排序要比冒泡排序更受欢迎呢？
冒泡排序和插入排序的时间复杂度都是 O(n2)，都是原地排序算法；
冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个：
```java
冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}
 
插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```
