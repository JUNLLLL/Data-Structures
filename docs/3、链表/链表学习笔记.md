# 链表学习笔记

链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针将一组零散的内存块串联起来实现的。

### 1、单链表

为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址,记录下个结点地址的指针叫作后继指针 next:
![单链表](单链表.jpg)
**头结点**用来记录链表的基地址，可以遍历得到整条链表。**尾结点**的指针不是指向下一个结点，而是指向一个**空地址 NULL**，表示这是链表上最后一个结点。

**Note: 链表中第一个结点的存储位置叫做头指针,可以没有头结点但不能没有头指针**，头结点是为了操作的统一与方便而设立的，放在第一个元素结点之前，其数据域一般无意义(存放链表的长度...)。

### 2、循环链表

循环链表是一种特殊的单链表，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。
![循环链表](循环链表.jpg)

### 3、双向链表
单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点：
![双向链表](双向链表.jpg)
向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间，**用空间换时间**。

### 4、关于顺序存储与链式存储中插入删除操作的效率PK
无论是单链表的插入操作还是删除操作，都是由两部分组成的：一是**遍历查找第i个元素**，二是**实现插入或删除操作**。

就整个算法而言，他们的时间复杂度都是O(n)，这样来看的话，再不知道要找的第i个元素所处的位置时，单链表的插入删除操作和顺序存储是没有什么优越性的。

但是！如果知道要插入或者删除的元素的位置时，链式存储就表现出它的优越性了。假如我们要在a10与a11之间插入10个元素，那么顺序存储每插入一个元素后面的元素就要移动一次位置，每次都是O(n)。而链式存储，只需要第一次时找到要插入的那个位置，后面的就只是赋值移动指针而已，时间复杂度为O(1)。

因此，可以得出一个结论：**对于插入或者删除操作越频繁的操作，单链表的效率优势就越是明显**

###  5、常见的链表操作
- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第 n 个结点
- 求链表的中间结点